#!/usr/bin/env python
# Add notes to readme
# brew install enchant
# GL windows, maybe a docker container?
# export PYENCHANT_LIBRARY_PATH=/opt/homebrew/lib/libenchant-2.dylib

import argparse
import datetime
from emoji import emojize, is_emoji
from utils import (
    encode_string,
    get_data_to_parse,
    initial_file_load,
    write_to_file,
)
import nltk
from nltk.corpus import stopwords, wordnet
from string import punctuation
import enchant
import os
import syllapy

d = enchant.Dict("en_GB")
nltk.download("wordnet")
nltk.download("stopwords")
stop_words = set(stopwords.words("english"))

invalid_words = []
SAVE_INVALID_WORDS = False


def score_word(word):
    length_score = len(word)
    age_score = 1
    complexity_score = 1

    synsets = wordnet.synsets(word)
    if synsets:
        earliest_synset = min(
            synsets, key=lambda synset: min(synset.lemma_names()).split(".")[0]
        )
        language = earliest_synset.lexname().split(".")[0]
        print(f"{word} => {earliest_synset}")
        if language == "old_english":
            age_score = 5.0
        elif language == "middle_english":
            age_score = 4.0
        elif language == "early_modern_english":
            age_score = 3.0
        elif language == "english":
            age_score = 2.0
        else:
            age_score = 1.0

        definitions = earliest_synset.lemma_names()
        num_definitions = len(definitions)
        num_syllables = syllapy.count(word)
        complexity_score = (num_definitions + 1) * (1 / (num_syllables + 1))

    # print(f"{num_definitions}, {num_syllables}")
    score = age_score * complexity_score

    return score


def verified_word(word):
    # Check for http in word
    if "http" in word:
        invalid_words.append(word)
        return None
    # Check if the word is numeric
    if word.isnumeric():
        invalid_words.append(word)
        return None
    # Check if the word is an emoji
    if is_emoji(emojize(word)):
        invalid_words.append(word)
        return None

    # Check if the word without punctuation still has a value
    if len(word.strip(punctuation)) > 0:
        # Check if the word is valid according to pyenchant
        if not d.check(word.strip(punctuation)):
            invalid_words.append(word)
            return None
    cleaned_word = "".join(e for e in encode_string(word, emojize=True) if e.isalnum())
    if cleaned_word not in stop_words:
        return cleaned_word


def emoji_or_noji(word, emojis_only):
    if word is None:
        return False
    if emojis_only is not True:
        return True
    if is_emoji(emojize(word)):
        return True
    return False


def list_every_word(all_messages, emojis_only):
    all_words = set()
    for message in all_messages:
        try:
            content = message.get("content", "")
            words = content.split(" ")

            for word in words:
                formatted_word = verified_word(word)
                if emoji_or_noji(formatted_word, emojis_only):
                    all_words.add(formatted_word)
        except KeyError:
            continue

    return list(all_words)


def main(
    data_to_parse,
    date_range_start,
    date_range_end,
    emojis_only,
    capture_context,
    compare_year,
):
    all_previous_years_words = set()

    if compare_year:
        today = datetime.now()
        messages, _ = get_data_to_parse(
            data_to_parse, "-".join([str(today.year), "01"]), None
        )
        all_messages, _ = get_data_to_parse(
            data_to_parse,
            None,
            "-".join([str(today.year - 1), "12"]),
        )
        all_previous_years_words = list_every_word(all_messages, emojis_only)

    else:
        messages, _ = get_data_to_parse(data_to_parse, date_range_start, date_range_end)

    word_data = {}
    sender_count = {}

    messages.reverse()
    for message in messages:
        try:
            words = message.get("content", "").lower().split(" ")
            sender_name = message.get("sender_name", "")
            for word in words:
                formatted_word = verified_word(word)
                if (
                    emoji_or_noji(formatted_word, emojis_only)
                    and formatted_word not in all_previous_years_words
                ):
                    if formatted_word in word_data.keys():
                        word_data[formatted_word]["count"] += 1
                    else:
                        word_data[formatted_word] = {
                            "count": 1,
                            "op": sender_name,
                        }
                        word_data[formatted_word]["score"] = score_word(word)

                        if capture_context:
                            word_data[formatted_word]["context"] = message.get(
                                "content", ""
                            )
                        sender_count[sender_name] = sender_count.get(sender_name, 0) + 1
        except KeyError:
            continue

    sorted_word_data = dict(
        sorted(word_data.items(), key=lambda item: item[1]["score"], reverse=True)
    )
    sorted_sender_count = dict(sorted(sender_count.items(), key=lambda item: item[1]))

    sorted_word_data["sender_count"] = sorted_sender_count
    if SAVE_INVALID_WORDS:
        sorted_word_data["invalid_words"] = sorted(list(dict.fromkeys(invalid_words)))

    write_to_file("unique_words.json", sorted_word_data)


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("-f", "--file", type=str, required=True)
    parser.add_argument("--multichat", type=bool, default=False)
    parser.add_argument(
        "--drstart",
        type=str,
        help="The date range start for getting messages, format needs to be (YYYY-MM)",
    )
    parser.add_argument(
        "--drend",
        type=str,
        help="The date range end for getting messages, format needs to be (YYYY-MM)",
    )
    parser.add_argument(
        "--emojis", type=bool, default=False, help="Only count emojis rather than words"
    )
    parser.add_argument(
        "--context", type=bool, default=False, help="Save the context of the word"
    )
    parser.add_argument(
        "--compareyear",
        type=bool,
        default=False,
        help="Compare the current year to the previous years",
    )

    args = parser.parse_args()
    if os.path.exists(args.file):
        main(
            initial_file_load(args.file, args.multichat),
            args.drstart,
            args.drend,
            args.emojis,
            args.context,
            args.compareyear,
        )
